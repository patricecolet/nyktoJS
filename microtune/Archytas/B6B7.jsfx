desc:nyktoJS Archytas B6B7 Chromatic (MIDI)
in_pin:none
out_pin:none

slider1:through=0<0,1,1{Off,On}>Through (pass-through)
slider2:key=0<0,11,1{C,C#,D,D#,E,F,F#,G,G#,A,A#,B}>Tonalité (tonic)
slider3:out_first_ch=1<1,16,1>Premier canal de voix
slider4:out_last_ch=8<1,16,1>Dernier canal de voix

// Applique l'échelle chromatique B6B7 via Pitch Bend par note.
// Convention PB: ±2 demi-tons, 8192 = centre, 1 cent = 40.96 pas.

@init
// Δcents par classe (ancrage ET: ET=100×classe, C..B)
// [0, 131, 67, 135, 98, 117, 102, 82, 84, 33, 49, -28]
b6b7_dev_cents[12];
b6b7_dev_cents[0]=0;  b6b7_dev_cents[1]=131; b6b7_dev_cents[2]=67;  b6b7_dev_cents[3]=135;
b6b7_dev_cents[4]=98; b6b7_dev_cents[5]=117; b6b7_dev_cents[6]=102; b6b7_dev_cents[7]=82;
b6b7_dev_cents[8]=84; b6b7_dev_cents[9]=33;  b6b7_dev_cents[10]=49; b6b7_dev_cents[11]=-28;

function bend14_from_dev(dev_cents) (
  v = 8192 + 40.96 * dev_cents;
  v < 0 ? v = 0 : v > 16383 ? v = 16383;
  floor(v + 0.5);
);

function class_no_mod(nn) (
  n = ((nn|0) % 12);
  (n < 0) ? (n += 12;);
  n;
);

// État polyphonique
voice_active[16];
voice_in_note[16];
voice_out_note[16];
last_bend14[16];

// Piles par note (jusqu'à 8 voix simultanées par même note)
note_count[128];
note_channels[128*8];
note_outnotes[128*8];
// Variables globales de POP
pop_ch = -1; pop_note = -1;

// Plage de canaux (0..15)
out_first = max(1,min(16,out_first_ch|0)) - 1;
out_last  = max(1,min(16,out_last_ch|0)) - 1;
(out_first > out_last) ? (out_first = 0; out_last = 15;);

// Init états
ch = 0; loop(16,
  voice_active[ch] = 0;
  voice_in_note[ch] = -1;
  voice_out_note[ch] = -1;
  last_bend14[ch] = 8192;
  ch += 1;
);
i=0; loop(128, note_count[i] = 0; i += 1;);
next_rr = out_first;

function stack_remove_channel(note_in, ch) (
  base = (note_in & 0x7F) * 8;
  cnt = note_count[note_in & 0x7F];
  i = 0; found = -1;
  while (i < cnt && found < 0) (
    (note_channels[base + i] == (ch & 0x0F)) ? (found = i;);
    i += 1;
  );
  (found >= 0) ? (
    last = cnt - 1;
    note_channels[base + found] = note_channels[base + last];
    note_outnotes[base + found] = note_outnotes[base + last];
    note_count[note_in & 0x7F] = last;
  );
);

function next_voice() (
  ret = next_rr;
  // Si le canal est occupé, arrêter l'ancienne note avant de la remplacer
  voice_active[ret] ? (
    midisend(0, (0x90 | (ret & 0x0F)), voice_out_note[ret] & 0x7F, 0);
    (voice_in_note[ret] >= 0) ? ( stack_remove_channel(voice_in_note[ret], ret); );
    voice_active[ret] = 0;
    voice_in_note[ret] = -1;
    voice_out_note[ret] = -1;
  );
  next_rr += 1;
  (next_rr > out_last) ? ( next_rr = out_first; );
  ret;
);

function stack_push(note_in, ch, out_note) (
  // Borne le canal dans la plage courante par sécurité
  (ch < out_first || ch > out_last) ? ( ch = out_first; );
  base = (note_in & 0x7F) * 8;
  cnt = note_count[note_in & 0x7F];
  (cnt < 8) ? (
    note_channels[base + cnt] = ch & 0x0F;
    note_outnotes[base + cnt] = out_note & 0x7F;
    note_count[note_in & 0x7F] = cnt + 1;
  );
);

// Nouvelle version: écrit dans pop_ch / pop_note
function stack_pop(note_in) (
  base = (note_in & 0x7F) * 8;
  cnt = note_count[note_in & 0x7F];
  (cnt > 0) ? (
    idx = cnt - 1;
    pop_ch   = note_channels[base + idx];
    pop_note = note_outnotes[base + idx];
    note_count[note_in & 0x7F] = idx;
  ) : (
    pop_ch = -1; pop_note = -1;
  );
);

// Recherche d’une voix active portant une note donnée
function find_active_ch_for_note(nn) (
  c = out_first; found = -1;
  while (c <= out_last && found < 0) (
    (voice_active[c] && voice_out_note[c] == (nn & 0x7F)) ? (found = c;);
    c += 1;
  );
  found;
);

@block
// Recalcule la plage de canaux d'après les sliders et recadre next_rr
new_first = max(1,min(16,out_first_ch|0)) - 1;
new_last  = max(1,min(16,out_last_ch|0)) - 1;
(new_first > new_last) ? ( new_first = 0; new_last = 15; );
((new_first != out_first) || (new_last != out_last)) ? (
  // Avant de changer de plage: All Notes Off et purge des piles
  chx = out_first; while (chx <= out_last) (
    (voice_active[chx] && voice_out_note[chx] >= 0) ? (
      midisend(0, 0x90 | (chx & 0x0F), voice_out_note[chx] & 0x7F, 0);
    );
    voice_active[chx] = 0;
    voice_in_note[chx] = -1;
    voice_out_note[chx] = -1;
    chx += 1;
  );
  i=0; while (i < 128) (
    note_count[i] = 0;
    i += 1;
  );
  out_first = new_first; out_last = new_last;
  (next_rr < out_first || next_rr > out_last) ? ( next_rr = out_first; );
);

perf_pb_cents = 0; // déviation PB de performance en cents

while (midirecv(offset, m1, m2, m3)) (
  st = m1 & 0xF0;
  in_ch = m1 & 0x0F;
  note = m2 & 0x7F;
  vel  = m3 & 0x7F;

  // Through complet
  through ? ( midisend(offset, m1, m2, m3); continue; );

  // Laisser passer les contrôleurs (CC)
  (st == 0xB0) ? ( midisend(offset, m1, m2, m3); continue; );

  // Pitch Bend entrant: convertir en cents et propager (additif avec PB microtonal de base)
  (st == 0xE0) ? (
    in_l = m2 & 0x7F; in_h = m3 & 0x7F;
    bend_in = (in_h << 7) | in_l;
    perf_pb_cents = (bend_in - 8192) / 40.96;
    chp = out_first;
    while (chp <= out_last) (
      voice_active[chp] ? (
        base_cents = (last_bend14[chp] - 8192) / 40.96;
        comb_bend = bend14_from_dev(base_cents + perf_pb_cents);
        l2 = comb_bend & 0x7F; h2 = (comb_bend >> 7) & 0x7F;
        midisend(offset, (0xE0 | (chp & 0x0F)), l2, h2);
      );
      chp += 1;
    );
    continue;
  );

  // Note Off explicite ou NoteOn vel=0
  ((st == 0x80) || (st == 0x90 && vel == 0)) ? (
    stack_pop(note);
    valid_pop = (pop_ch >= out_first && pop_ch <= out_last) && (pop_note >= 0);
    (valid_pop == 0) ? (
      alt_ch = find_active_ch_for_note(note);
      (alt_ch >= 0) ? ( pop_ch = alt_ch; pop_note = note & 0x7F; valid_pop = 1; );
    );
    valid_pop ? (
      midisend(offset, (0x90 | (pop_ch & 0x0F)), pop_note & 0x7F, 0);
      voice_active[pop_ch] = 0;
      voice_in_note[pop_ch] = -1;
      voice_out_note[pop_ch] = -1;
    );
    continue;
  );

  // Note On
  (st == 0x90) ? (
    cls_in  = class_no_mod(note);
    k = class_no_mod(key);
    idx = (cls_in - k + 12) % 12;

    vc = next_voice();

    // PB selon tonalité
    dev = (
      idx == 0 ? 0 :
      idx == 1 ? 131 :
      idx == 2 ? 67 :
      idx == 3 ? 135 :
      idx == 4 ? 98 :
      idx == 5 ? 117 :
      idx == 6 ? 102 :
      idx == 7 ? 82 :
      idx == 8 ? 84 :
      idx == 9 ? 33 :
      idx == 10 ? 49 :
      -28
    );
    base_bend = bend14_from_dev(dev);
    last_bend14[vc] = base_bend; // mémoriser PB microtonal de base pour la voix

    // Ajouter PB de performance courant (en cents)
    comb_bend2 = bend14_from_dev(dev + perf_pb_cents);
    lsb2 = comb_bend2 & 0x7F; msb2 = (comb_bend2 >> 7) & 0x7F;

    // PB combiné puis Note au même offset
    midisend(offset, (0xE0 | (vc & 0x0F)), lsb2, msb2);
    midisend(offset, (0x90 | (vc & 0x0F)), note, vel);

    // Mémoriser pour OFF
    voice_active[vc] = 1;
    voice_in_note[vc] = note & 0x7F;
    voice_out_note[vc] = note & 0x7F;
    stack_push(note, vc, note);
    continue;
  );

  // Autres messages: ne rien émettre si Through=Off
  continue;
);



