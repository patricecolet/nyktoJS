desc:nyktoJS Archytas B7 Microtune (MIDI)
in_pin:none
out_pin:none

// Réaccordage microtonal Archytas B7
// - 1 entrée MIDI -> 16 canaux de sortie pour la polyphonie
// - Table B7 (mod 12) -> (mod 12, offset unités) avec 4096 unités = 1 demi-ton
// - Application du Pitch Bend entrant: 8192=centre, 16383=+1 ton B7, 0=-1 ton B7

slider1:out_first_ch=1<1,16,1>Premier canal de voix
slider2:out_last_ch=16<1,16,1>Dernier canal de voix
slider3:pb_range=2<1,24,1>Plage Pitch Bend de l'instrument (en demi-tons)
slider4:send_rpn=1<0,1,1{Off,On}>Envoyer RPN pour configurer la plage PB
slider5:bypass=0<0,1,1{Off,On}>Bypass (pass-through)

@init
// Bornes canaux
out_first = max(1, min(16, out_first_ch|0)) - 1; // 0..15
out_last  = max(1, min(16, out_last_ch|0)) - 1;  // 0..15
(out_first > out_last) ? (
	out_first = 0; out_last = 15;
);

// Table Archytas B7: target classe (mod 12) et offset en unités (4096=1 demi-ton)
// index = classe d'entrée mod 12
b7_target[12];
b7_units[12];

b7_target[0]=0;  b7_units[0]=0;
b7_target[1]=2;  b7_units[1]=2539;
b7_target[2]=2;  b7_units[2]=2539;
b7_target[3]=4;  b7_units[3]=2867;
b7_target[4]=4;  b7_units[4]=2867;
b7_target[5]=6;  b7_units[5]=1475;
b7_target[6]=6;  b7_units[6]=1475;
b7_target[7]=7;  b7_units[7]=6717;
b7_target[8]=9;  b7_units[8]=2703;
b7_target[9]=9;  b7_units[9]=2703;
b7_target[10]=10; b7_units[10]=5898;
b7_target[11]=10; b7_units[11]=5898;

// Constante: 1 ton B7 en unités = 4096 * (12/7)
B7_STEP_UNITS = 4096 * 12 / 7;

// État par voix
voice_in_note[16];
voice_out_note[16];
voice_active[16];
last_bend14[16];
pending_rpn_flag[16];
ignore_noteoff[128];

ch = 0;
loop(16,
	voice_in_note[ch] = -1;
	voice_out_note[ch] = -1;
	voice_active[ch] = 0;
	last_bend14[ch] = 8192;
	pending_rpn_flag[ch] = 1;
	ch += 1;
);

next_rr = out_first;

// Init ignore flags
i = 0;
loop(128, ignore_noteoff[i] = 0; i += 1;);

// Pitch Bend entrant normalisé
pb_in14 = 8192;
pb_u = 0; // (pb_in14-8192)/8192 in [-1,1]

function clamp(v,lo,hi) (
	v < lo ? lo : v > hi ? hi : v;
);

function to14bit_bend(delta_semitones) (
	8192 + (delta_semitones / pb_range) * 8192;
);

function send_bend_if_changed(ch, bend14, offs) (
	b = floor(clamp(bend14, 0, 16383) + 0.5);
	b != last_bend14[ch] ? (
		lsb = b & 0x7F;
		msb = (b >> 7) & 0x7F;
		midisend(offs, 0xE0 | ch, lsb, msb);
		last_bend14[ch] = b;
	);
);

function send_rpn_pb_range(ch) (
	sems = (pb_range|0) & 0x7F;
	midisend(0, 0xB0 | ch, 101, 0);
	midisend(0, 0xB0 | ch, 100, 0);
	midisend(0, 0xB0 | ch, 6, sems);
	midisend(0, 0xB0 | ch, 38, 0);
	midisend(0, 0xB0 | ch, 101, 127);
	midisend(0, 0xB0 | ch, 100, 127);
	pending_rpn_flag[ch] = 0;
);

function allocate_voice(note_in, offs) (
	c = out_first;
	while (c <= out_last && voice_active[c]) (
		c += 1;
	);
	c <= out_last ? ret=c : (
		ret = next_rr;
		voice_active[ret] ? (
			// Tuer note en vol si nécessaire
			midisend(offs, 0x90 | ret, voice_out_note[ret], 0);
		);
		next_rr += 1; (next_rr > out_last) ? next_rr = out_first;
	);
	ret;
);

function find_voice_by_input(note_in) (
	c = out_first; found = -1;
	while (c <= out_last && found < 0) (
		(voice_active[c] && voice_in_note[c] == note_in) ? found = c;
		c += 1;
	);
	found;
);

function find_any_active_voice() (
	c = out_first; found = -1;
	while (c <= out_last && found < 0) (
		voice_active[c] ? found = c;
		c += 1;
	);
	found;
);

function compute_b7_bend_units(note_in) (
	cls = note_in % 12;
	units = b7_units[cls] + pb_u * B7_STEP_UNITS;
	units;
);

function quantize_note_b7(note_in) (
	cls = note_in % 12;
	delta_class = b7_target[cls] - cls;
	note_in + delta_class;
);

function update_channel_bend(ch, offs) (
	units = compute_b7_bend_units(voice_in_note[ch]);
	delta_semi = units / 4096;
	bend14 = to14bit_bend(delta_semi);
	send_bend_if_changed(ch, bend14, offs);
);

@slider
out_first = max(1, min(16, out_first_ch|0)) - 1;
out_last  = max(1, min(16, out_last_ch|0)) - 1;
(out_first > out_last) ? (out_first = 0; out_last = 15;);

// Armer RPN si plage ou bornes changent
rearm = 0;
(pb_range != last_pb_range) ? rearm = 1;
(out_first != last_out_first) || (out_last != last_out_last) ? rearm = 1;
rearm ? (
	c = 0; loop(16, pending_rpn_flag[c] = 1; c += 1;);
);
last_pb_range = pb_range;
last_out_first = out_first;
last_out_last = out_last;

@block
bypass ? (
	while (midirecv(ofs, a,b,c)) (
		midisend(ofs, a,b,c);
	);
	return;
);

while (midirecv(offset, msg1, msg2, msg3)) (
	status = msg1 & 0xF0;
	in_ch = msg1 & 0x0F;

	status == 0xE0 ? (
		// Pitch Bend entrant -> normaliser et mettre à jour toutes les voix actives
		pb_in14 = (msg3 << 7) | (msg2 & 0x7F);
		pb_u = (pb_in14 - 8192) / 8192; // [-1,1]
		c = out_first; while (c <= out_last) (
			voice_active[c] ? update_channel_bend(c, offset);
			c += 1;
		);
		// On ne relaye pas le PB d'origine tel quel
		continue;
	);

	(status == 0x90 || status == 0x80) ? (
		note = msg2 & 0x7F; vel = msg3 & 0x7F;
		// Note Off
		((status == 0x80) || (status == 0x90 && vel == 0)) ? (
			vc = find_voice_by_input(note);
			vc >= 0 ? (
				voice_active[vc] = 0;
				midisend(offset, 0x90 | vc, voice_out_note[vc], 0);
				voice_in_note[vc] = -1; voice_out_note[vc] = -1;
			) : (
				// Si tué en avance (mono), filtrer la Note Off d'origine
				(ignore_noteoff[note] == 1) ? (ignore_noteoff[note] = 0;) : (midisend(offset, msg1, msg2, msg3));
			);
			continue;
		);

		// Note On (entrée mono): si une note est active, l'éteindre et filtrer son Note Off ultérieur
		mono_ch = find_any_active_voice();
		mono_ch >= 0 ? (
			midisend(offset, 0x90 | mono_ch, voice_out_note[mono_ch], 0);
			ignore_noteoff[voice_in_note[mono_ch]] = 1;
			voice_active[mono_ch] = 0;
			voice_in_note[mono_ch] = -1;
			voice_out_note[mono_ch] = -1;
		);
		// Note On
		vc = allocate_voice(note, offset);
		voice_in_note[vc] = note;
		qnote = quantize_note_b7(note);
		voice_out_note[vc] = qnote;
		voice_active[vc] = 1;

		send_rpn && pending_rpn_flag[vc] ? send_rpn_pb_range(vc);
		update_channel_bend(vc, offset);
		midisend(offset, 0x90 | vc, qnote, vel);
		continue;
	) : (
		// Relayer autres messages MIDI tels quels
		midisend(offset, msg1, msg2, msg3);
	);
);
