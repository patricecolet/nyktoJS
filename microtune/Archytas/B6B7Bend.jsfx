desc:nyktoJS Archytas B6B7 Bend (MIDI)
in_pin:none
out_pin:none

slider1:through=0<0,1,1{Off,On}>Through (pass-through)
slider2:key=0<0,11,1{C,C#,D,D#,E,F,F#,G,G#,A,A#,B}>Tonalité (tonic)
slider3:out_first_ch=1<1,16,1>Premier canal de voix
slider4:out_last_ch=8<1,16,1>Dernier canal de voix
slider5:pb_span=1<1,2,1>Étendue PB (demi-tons)

// Archytas: PB mappé pour atteindre exactement le degré ±N à la butée, sans retrigger.
// Convention: 8192 = centre, ±8192 = ±2 demi-tons (±200 cents). On interpole en cents entre
// abs0 = 100*classe + Δcents(classe) et absN = 100*(classe±N) + Δcents(classe±N), avec t = |PB|/8192.

@init
// Δcents par classe (ancrage ET: ET=100×classe, C..B)
// [0, 131, 67, 135, 98, 117, 102, 82, 84, 33, 49, -28]
b6b7_dev_cents[12];
b6b7_dev_cents[0]=0;  b6b7_dev_cents[1]=131; b6b7_dev_cents[2]=67;  b6b7_dev_cents[3]=135;
b6b7_dev_cents[4]=98; b6b7_dev_cents[5]=117; b6b7_dev_cents[6]=102; b6b7_dev_cents[7]=82;
b6b7_dev_cents[8]=84; b6b7_dev_cents[9]=33;  b6b7_dev_cents[10]=49; b6b7_dev_cents[11]=-28;

function bend14_from_dev(dev_cents) (
  v = 8192 + 40.96 * dev_cents;
  v < 0 ? v = 0 : v > 16383 ? v = 16383;
  floor(v + 0.5);
);

function class_no_mod(nn) (
  n = ((nn|0) % 12);
  (n < 0) ? (n += 12;);
  n;
);

function cls_map(c, tonic) (
  ((c - tonic + 12) % 12);
);

// État polyphonique
voice_active[16];
voice_in_note[16];
voice_out_note[16];

// Piles par note (jusqu'à 8 voix simultanées par même note)
note_count[128];
note_channels[128*8];
note_outnotes[128*8];
// Variables globales de POP
pop_ch = -1; pop_note = -1;

// Plage de canaux (0..15)
out_first = max(1,min(16,out_first_ch|0)) - 1;
out_last  = max(1,min(16,out_last_ch|0)) - 1;
(out_first > out_last) ? (out_first = 0; out_last = 15;);

// Init états
ch = 0; loop(16,
  voice_active[ch] = 0;
  voice_in_note[ch] = -1;
  voice_out_note[ch] = -1;
  ch += 1;
);
i=0; loop(128, note_count[i] = 0; i += 1;);
next_rr = out_first;

function next_voice() (
  ret = next_rr;
  next_rr += 1;
  (next_rr > out_last) ? ( next_rr = out_first; );
  ret;
);

function stack_push(note_in, ch, out_note) (
  (ch < out_first || ch > out_last) ? ( ch = out_first; );
  base = (note_in & 0x7F) * 8;
  cnt = note_count[note_in & 0x7F];
  (cnt < 8) ? (
    note_channels[base + cnt] = ch & 0x0F;
    note_outnotes[base + cnt] = out_note & 0x7F;
    note_count[note_in & 0x7F] = cnt + 1;
  );
);

function stack_pop(note_in) (
  base = (note_in & 0x7F) * 8;
  cnt = note_count[note_in & 0x7F];
  (cnt > 0) ? (
    idx = cnt - 1;
    pop_ch   = note_channels[base + idx];
    pop_note = note_outnotes[base + idx];
    note_count[note_in & 0x7F] = idx;
  ) : (
    pop_ch = -1; pop_note = -1;
  );
);

function stack_remove_channel(note_in, ch) (
  base = (note_in & 0x7F) * 8;
  cnt = note_count[note_in & 0x7F];
  i = 0; found = -1;
  while (i < cnt && found < 0) (
    (note_channels[base + i] == (ch & 0x0F)) ? (found = i;);
    i += 1;
  );
  (found >= 0) ? (
    last = cnt - 1;
    note_channels[base + found] = note_channels[base + last];
    note_outnotes[base + found] = note_outnotes[base + last];
    note_count[note_in & 0x7F] = last;
  );
);

// Applique le PB mappé à une voix donnée
function apply_pb_for_ch(ch_idx, bend_in14) (
  cls = class_no_mod(voice_out_note[ch_idx]);
  k = class_no_mod(key);
  idx0 = cls_map(cls, k);
  dev0 = b6b7_dev_cents[idx0|0];
  abs0 = 100*cls + dev0;
  // Normaliser la roue: f in [-1..1]
  f = (bend_in14 - 8192) / 8192;
  s = (f >= 0) ? 1 : -1;
  mag = (f >= 0) ? f : -f;
  span = (pb_span|0);
  clsN = (cls + s*span + 120) % 12;
  idxN = cls_map(clsN, k);
  devN = b6b7_dev_cents[idxN|0];
  absN = 100*clsN + devN;
  absOut = abs0 + (absN - abs0) * mag;
  devOut = absOut - 100*cls;
  b14 = bend14_from_dev(devOut);
  l = b14 & 0x7F; h = (b14 >> 7) & 0x7F;
  midisend(offset, (0xE0 | (ch_idx & 0x0F)), l, h);
);

@block
// Recalcule la plage de canaux d'après les sliders et recadre next_rr
new_first = max(1,min(16,out_first_ch|0)) - 1;
new_last  = max(1,min(16,out_last_ch|0)) - 1;
(new_first > new_last) ? ( new_first = 0; new_last = 15; );
((new_first != out_first) || (new_last != out_last)) ? (
  chx = out_first; while (chx <= out_last) (
    (voice_active[chx] && voice_out_note[chx] >= 0) ? (
      midisend(0, 0x90 | (chx & 0x0F), voice_out_note[chx] & 0x7F, 0);
    );
    voice_active[chx] = 0;
    voice_in_note[chx] = -1;
    voice_out_note[chx] = -1;
    chx += 1;
  );
  i=0; while (i < 128) (
    note_count[i] = 0;
    i += 1;
  );
  out_first = new_first; out_last = new_last;
  (next_rr < out_first || next_rr > out_last) ? ( next_rr = out_first; );
);

// Dernier PB entrant mémorisé
last_in_bend14 = 8192;

while (midirecv(offset, m1, m2, m3)) (
  st = m1 & 0xF0;
  note = m2 & 0x7F;
  vel  = m3 & 0x7F;

  through ? ( midisend(offset, m1, m2, m3); continue; );

  // PB entrant: stocke et applique à toutes les voix actives
  (st == 0xE0) ? (
    last_in_bend14 = ((m3 & 0x7F) << 7) | (m2 & 0x7F);
    chp = out_first; while (chp <= out_last) (
      voice_active[chp] ? (
        apply_pb_for_ch(chp, last_in_bend14);
      );
      chp += 1;
    );
    continue;
  );

  // Note Off explicite ou NoteOn vel=0
  ((st == 0x80) || (st == 0x90 && vel == 0)) ? (
    stack_pop(note);
    valid_pop = (pop_ch >= out_first && pop_ch <= out_last) && (pop_note >= 0);
    (valid_pop == 0) ? (
      // fallback: chercher la voix portant cette note
      ch_scan = out_first; found = -1;
      while (ch_scan <= out_last && found < 0) (
        (voice_active[ch_scan] && voice_out_note[ch_scan] == (note & 0x7F)) ? (found = ch_scan;);
        ch_scan += 1;
      );
      (found >= 0) ? (pop_ch = found; pop_note = note & 0x7F; valid_pop = 1;);
    );
    valid_pop ? (
      midisend(offset, (0x90 | (pop_ch & 0x0F)), pop_note & 0x7F, 0);
      voice_active[pop_ch] = 0;
      voice_in_note[pop_ch] = -1;
      voice_out_note[pop_ch] = -1;
    );
    continue;
  );

  // Note On: allocation, PB initial selon last_in_bend14, puis Note
  (st == 0x90) ? (
    vc = next_voice();
    midisend(offset, (0x90 | (vc & 0x0F)), note, vel);
    voice_active[vc] = 1;
    voice_in_note[vc] = note & 0x7F;
    voice_out_note[vc] = note & 0x7F;
    stack_push(note, vc, note);
    // Appliquer PB mappé actuel
    apply_pb_for_ch(vc, last_in_bend14);
    continue;
  );

  // Autres messages ignorés si Through=Off
  continue;
);
